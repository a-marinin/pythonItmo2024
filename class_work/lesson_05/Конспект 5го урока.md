## Урок 5. Функция map(). Декораторы

### Функция map()
Функция map() даёт возможность примерить функцию к каждому элементу итерируемого объекта. 
Итерируемым объектом может быть либо список, либо кортеж, либо какая-то строка.  
В пером аргументе мы можем передать не только обычную функцию, то и писать lambda функцию.  
Функция map() перебирает элементы массива и возвращает новый массив, который является результатом применения функции преобразования к каждому элементу исходного массива.  

Схема функции map(), в таком случае, будет такой:

    map(функция, список) 

Маппинг - это сопоставление. 

### Задача №1 
Иммется строка.   
Напишите сопоставленик, которое возвращает список, состоящий из букв исходной строки в верхнем регистре.

### Решение задачи №1
    string_upper = 'Mapping'
    print(list(map(lambda x: x.upper(), string_upper)))  # Результат: ['M', 'A', 'P', 'P', 'I', 'N', 'G']

### Декораторы
Декоратор - это функция, которая принимает в качетсве аргумента другую (оригинальную) функцию и изменяет её поведени, не изменяя саму функцию.  
Декоратор возвращает другую функцию (то есть замыкание). 
Декоратор можно написать, чтобы не бояться сломать исходную функцию/функции. Но дополнить их как-то (например, логированием).

### Задача №2
Предусловия:
1. Для начала определим функцию price_calculation()
2. Функция рассчитывает итоговую стоимость исходя из цены и налога. Она возвращает число

Задача:
1. Преобразовать результат работы функции в строку и добавлять " руб."
т.е. итоговый результат должен выглядеть так "100 руб." 

        def price_calculation(price, tax):
        return price * (1 + tax)

Решение: 
1. Для решения создадим декоратор.  
2. По определению, декоратор - это функция, которая принимает функцию в качестве аргумента и возвращает другую функцию:
   1. Создали функцию-декоратор (currency) принимает в себя другую функцию (fn) в качестве аргумента.
   2. В теле функции (currency) создаём другую функцию (wrapper), которая принимает неизвестное количество позиционных (*args) и именнованных (**kwargs) аргументов.
   3. В теле функции (wrapper) вызывает функцию, которую мы приняли в качетсве аргумента (fn) с этими же параметрами.


    # Декоратор (только скелет декоратора)
    def currency(fn):  #
        def wrapper(*args, **kwargs):  
            fn(*args, **kwargs)
    
    return wrapper

Сама функция wrapper не запускается внутри декоратора. Она возвращается. 
Мы просто в конце возвращаем "return wrapper". Тут ещё запуска нет.

1. Доработаем наш декоратор, чтобы он выполнял условия задачи:


    # Доработанный декоратор (чтобы он выполнял условия задачи)
    def currency(fn):
        def wrapper(*args, **kwargs):
            result = fn(*args, **kwargs)
            return f'{result} руб.'
        return wrapper

По сути наш декоратор готов.  
Осталось только задекорировать нашу функцию. 
Как это делается? 

- Функция currency() - это декоратор. 
- currency() принимает в качестве аргумента любую другую функцию и возвращает результат этой функции с дополнением " руб."
- Чтобы использовать декоратор, нужно передать функцию price_calculation, чтобы получить новую функцию и выполнить её, как если бы это была исходная функция:


    # Декорируем нашу функцию
    price_calculation = currency(price_calculation)  # Переобпределили price_calculation, задекорировав её currency. 
    print(price_calculation((100, 0.05)))  # Результат: 105.0 руб.

Это не единственный способ. В Python есть более сокращённая запись декорирования.  
Для этого существует специальный символ.  
В Python есть более короткий способ декорирования - с помощью символа @

Синтаксис:
    
    @декоратор
    def функция():
        тело функции

Если нам нужно только логировать - то мы можем не производить изменения результата.  
В таком случае мы добавляем к декоратору строчку с логгированием и возвращаем просто функцию, которая была передана.  
Возвращать нужно всего что-то. 

    def currency(fn):
    def wrapper(*args, **kwargs):
        result = fn(*args, **kwargs)
        print("Была запущена функция: ", fn.__name__)  # Просто логгирование (для удобства)
        # return f'{result} руб.'  # Не возвращаем, не производим преобразования
        return fn(*args, **kwargs)  # Возвращаем просто вызов функции fn.
    return wrapper

### Задача №3
1. Напишите две функции:
   1. Возвращает квадрат принимаемого числа
   2. Возвращает произведение принимаемого числа и 2
2. Напишите декоратор, который добавляет к результату декорируемой функции строку "Результат вычислений: "
3. Задекорируйте обе функции и выведите результат в консоль. 

### Решение задачи №3
    def print_result(f):  # Это декоратор
        def result(x):  # Такая запись возможно, если мы точно уведерены, что все функции будут принимать только 1 аргумент
            r = f(x)  # Вызывает функцию, которую мы принями в качестве аргумента, передаём в неё x
            print(f'Результат вычислений: {r}')
            return r
        return result
    
    
    @print_result
    def square(x):  # Это Функция 1 - возвращает квадрат числа
        return x ** 2
    
    
    @print_result  # Это Функция 2 - возвращает произведения числа и 2-х
    def multiply(x):
        return x * 2
    
    
    square(3)  # Результат вычислений: 9
    multiply(3)  # Результат вычислений: 6


### Аргументы декоратора
В каждый декоратор мы можем передавать его личные аргументы.  
Ведь декоратор - это же функция, соответственно она может также принимать какие-то аргументы.  

Зачем это требуется?   
Например, если в нашем первом примере (задача №2) мы хотели бы выводить не строго "руб.", а какую-то валюту.  
При этом эту валюту мы хотим передавать для каждой функции отдельно.   

Но если мы это сделаем просто так (в декоратор пошлём какие-то аргументы, - то у нас будет ошибка "TypeError: 'str' object is not callable")
Для того, чтобы наш декоратор мог принимать какие-то аргументы, - то нам нужно будте его модифицировать. 

Если коротко: Сделать ещё одно вложение функции. 
Пример: модифицируем предыдущую задачку:

      # Декоратор
      def currency(currency_name):  # Функция currency примет аргумент с названием валюты
          def decor(fn):  # Создаётся декоратор, который возвращаем результат с типом валюты, примет функцию
              def wrapper(*args, **kwargs):
                  result = fn(*args, **kwargs)
                  return f'{result} {currency_name}'
              return wrapper
          return decor  # Возвращаем без вызова, просто название функции. () - Не нужно!
      
      
      # Оригинальная функция
      @currency('$')
      def price_calculation(price, tax):
          return price * (1 + tax)
      
      
      # Декорируем нашу функцию
      print(price_calculation(100, 0.05))  # Результат: 105.0 руб./$ и т.п.

Вывод: декоратор - это очень мощный инструмент.  
Он позволяет делать какие-то маленькие дополнения на большом объёме кода.  
То есть, если у нас таких функций много, например, 5-6, то мы можем написать отдельный декоратор и, соответственно, изменить большое колличество кода маленькой записью.
Не изменять все 6 функций. 