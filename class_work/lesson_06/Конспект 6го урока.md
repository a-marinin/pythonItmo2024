## Урок 5. ООП. Часть 1 - классы, объекты, методы и атрибуты

### ООП
Объектно-ориентированное программирование (сокр. ООП) — методология программирования, основанная на представлении программы в виде совокупности взаимодействующих объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

### Пример ООП № 1
Рассмотрим на примере автомобилей  
Класс - это чертеж машины, а экземпляры этого класса - конкретные машины.  
Машины собраны по одному чертежу, умеют одинаково ездить, но обладают собственным уникальным состоянием.  
Состояние - это ряд меняющихся свойств. Поэтому у двух разных объектов одного класса мы можем наблюдать разный номер, цвет и т. д.  
Само наличие этих свойств и их типы описываются в классе.  
Класс - это описание того, какими свойствами и поведением будет обладать объект.  
Объект - это экземпляр класса с собственным состоянием этих свойств.  

У каждой машины есть какие-то данные и с ней можно делать какие-то действия.  
В методологии ООП такие вещи называются атрибуты и методы.  

### Пример ООП № 2
Допустим объектами нашей программы являются студенты.  
Нам требуется хранить и обрабатывать информацию о студентах. В некоторых случаях производить над студентами действия.    
Класс - описание студента. Набор его методов и атрибутов.  
Объект - конкретный студент. Его создали, присвоили ему данные в соответствии с классом. С ним можно производить различные действия.  
возраст, пол, ФИО, курс - это атрибуты класса.  
зачислить, отчислить, перевести на другой курс - это методы класса.  

### Синтаксис классов
В Python классы создаются через ключевое слово class, за ним следует название класса и родительские классы.
Синтаксис:

    class Name:

    class Name(PatentClass1, ParentClass2):

### Свойства, атрибуты и методы
Свойства класса задаются как обычные переменные:

    class Name:
        attr1 = 17
        attr2 = "Hello"

Методы класса задаются как функции внутри класса:
    
    class Name:
    
    def method(self, x):
        # код метода

### Внутренний объект класса self
self - это имя для ссылки на объект, в контекстве которого вызывается метод.  
Этот параметр обязателен и отличает метод класса от обычной функции.  

Благодаря self мы можем получить доступ к атрибутам и методам класса в любом месте этого класса.


    class Name:
    
    def method1(self, x):
        print(x)
    
    def method2(self):
        self.method(5)

### Задача 1 (Пример создание класса)
1. Создайте файл "student.py"
2. Опишите класс Student:
        

    class Student:
        profession = 'Developer'
        
        def check_profession(self):
            print(self.profession)
3. Создайте объект по этому классу:
   (создание объекта по классу (инициализация объекта) происходит как создание простой переменной)

    
    new_student = Student()

У классов существуют специальные методы.
Основной такой метод это __init__.  
Метод требуются для создания атрибутов - т.е. переменных значения, которым присваиваются при создании объекта. 

    
    class Student:
    profession = 'Developer'

    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.age = age

    def check_profession(self):
        print(self.profession)


    new_student = Student(first_name='Иван', last_name='Иванов', age=22)

Все методы и атрибуты дсотпны в объекте.  
Вызываются они через точку.  


      new_student = Student(first_name='Иван', last_name='Иванов', age=22)
      
      new_student.check_profession()
      
      print(new_student.age)
      print(new_student.first_name)
      print(new_student.last_name)

### Задача №2
1. Создайте файл soda.py
2. Создайте класс Soda (для определения типа газированной воды).
3. Класс принимает 1 аргумент при инициализации (отвечающий за добавку к выбираемому лимонаду).
4. В этом классе реализуйте метод show_my_drink():
   1. Метод должен выводить на печать "Газировка и {ДОБАВКА}" если добавка есть
   2. Или если добавки нет выводить "Обычная газировка"
5. Для теста класса:
   1. Создайте 2 объекта, один с добавкой, другой без
   2. Вызовите метод show_my_drink() для каждого объекта

### Решение задачи №2
      class Soda:
          def __init__(self, ing=None):
              self.ing = ing
      
          def show_my_drink(self):
              if self.ing:
                  print(f'Газировка и {self.ing}')
      
              else:
                  print('Обычная газировка')
      
      
      drink1 = Soda()
      drink2 = Soda('Малина')
      drink1.show_my_drink()
      drink2.show_my_drink()
      
      
      # Результат:
      '''
      Обычная газировка
      Газировка и Малина
      '''


### Метод \_\_new\_\_
Метод вызывается непосредственно перед созданием экзампляра класса.  
Метода часто применяется для реализации паттерна Singleton.  
(Singleston - это шаблок проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса).

      class Student:
          profession = 'Developer'
      
          def __new__(cls, *args, **kwargs):
              print('new')
              return super().__new__(cls)
      
          def __init__(self, first_name, last_name, age):
              self.first_name = first_name
              self.last_name = last_name
              self.age = age


### Задача №3
1. Создайте файл DataBase.py
2. Создайте класс DataBase, при инициализации класс принимает три атрибута:
   - user
   - password
   - port
3. Создайте 2 метода:
   1. Метод connect - выводит на печать строку "Соединение в БД: {user}, {password}, {port}"
   2. Метод close - (статический метод) выводит на печать строку "Закрытие соединения в БД"

### Решение задачи №3
1. Собираем скелет Singletone (основа)


      class DataBase:
          def __init__(self, user, password, port):
              self.user = user
              self.password = password
              self.port = port  
              
          def connect(self):
              print(f"Соединение в БД: {self.user}, {self.password}, {self.port}")
                     
          @staticmethod
          def close():
              print("Закрытие соединения в БД")

1. Полагаем, что в программе должен существовать только один экземпляр этого класса в каждый момент её работы.  
То есть, одновременно два объекта класса DataBase быть не должно.  
2. Для этого добавим метод new в класс, следующим образом (добавляем его на первую позицию):


      class DataBase:
          __instance = None
          
          def __new__(cls, *args, **kwargs):
              if cls.__instance is None:
                  cls.__instance = super().__new__(cls)
                  
              return cls.__instance
          
          def __init__(self, user, password, port):
              self.user = user
              self.password = password
              self.port = port

3. Проверяем:
   1. Создаём 2 объекта для теста и запускаем программу
   - При второй инициализации не создаётся новый объект, но перезаписываются атрибуты.


      db1 = DataBase(user='root', password='1234', port=88)
      db2 = DataBase(user='root2', password='5678', port=40)
      print(id(db1), id(db2))
      
      db1.connect()
      db2.connect()
      
      # Результат:
      '''
      4333961824 4333961824
      Соединение в БД: root2, 5678, 40
      Соединение в БД: root2, 5678, 40
      '''